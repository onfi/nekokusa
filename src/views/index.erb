<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nekosuna</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.11/ace.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.11/theme-tomorrow_night_eighties.min.js" integrity="sha256-Kq3aVoDYV3fiszUucwvQabgLpYDXKs9zPu8i4N6dH4M=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.11/keybinding-sublime.min.js" integrity="sha256-VqhfCaWgaN+XFhrBj1AaJ+xmS0m3AxgezrmQT6B0h+g=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.11/mode-c_cpp.min.js" integrity="sha256-I5GO6mGnGNU1W/8viy4CsR98MZoZ3cq96WmrJQIWqLs=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <link rel="stylesheet" href="/style.css"></link>
</head>
<body>
    <header>Nekosuna <span>C++ programming environment for a coding competition</span></header>
    <div id="editor" style="height: 600px"></div>
    <div id="app" v-cloak>
        <div class="command">
            <input type="button" value="load" @click="load">
            <input type="button" value="build & run" @click="buildRun">
        </div>
        <div class="build">
            <h2>Compile result</h2>
            <div :class="compileResult">
                {{ compileResult }}
            </div>
            <div v-if="buildResult.STDOUT">
                <h4>STDOUT</h4>
                <pre>{{ buildResult.STDOUT }}</pre>
            </div>
            <div v-if="buildResult.STDERR">
                <h4>STDERR</h4>
                <pre>{{ buildResult.STDERR }}</pre>
            </div>
        </div>
        <div class="tests">
            <h2>test</h2>
            <div v-for="(test, index) in tests" :class="{ none : test.RESULT === null, success : test.RESULT, failure : test.RESULT === false }">
                test #{{ index }} : {{ test.RESULT === null ? 'not yet testing' : test.RESULT ? 'AC ' + test.TIME + 'ms' : 'WA' + (test.NUM_RESULT ? 'diff:' + test.NUM_RESULT : '') }}
            </div>
            <div v-for="(test, index) in tests" class="test">
                <h3>test #{{ index }}</h4>
                <textarea v-model="test.STDIN" id="" cols="120" rows="20" placeholder="Input STDIN"></textarea>
                <textarea v-model="test.EXPECT" id="" cols="120" rows="20" placeholder="Input expect STDOUT"></textarea>
                <div v-if="test.STDOUT">
                    <h4>STDOUT</h4>
                    <pre>{{ test.STDOUT }}</pre>
                </div>
                <div v-if="test.STDERR">
                    <h4>STDERR</h4>
                    <pre>{{ test.STDERR }}</pre>
                </div>
                <div v-if="test.STATUS">
                    <h4>STATUS</h4>
                    <pre>{{ test.STATUS }}</pre>
                </div>
            </div>
            <input type="button" value="add" @click="add">
        </div>
    </div>
    <script>
        const AceRange = ace.require("ace/range").Range
        let editor = ace.edit("editor")
        editor.setKeyboardHandler("ace/keyboard/sublime")
        editor.setTheme("ace/theme/tomorrow_night_eighties")
        editor.session.setMode("ace/mode/c_cpp")
        editor.setValue(localStorage.getItem("src") || `#include <bits/stdc++.h>
#define debug(x) cerr << #x << " = " << (x) << " (L" << __LINE__ << ")" << endl;
using namespace std;
int main() {
    string s;
    cin >> s;
    for(auto&& c : s) {
        cout << 'x';
    }
}`)
        editor.focus()
        editor.gotoLine(1)
        function newTest(stdin, expect) {
            return {
                "STDIN" : stdin,
                "EXPECT" : expect,
                "STDOUT" : null,
                "STDERR" : null,
                "STATUS" : null,
                "RESULT" : null,
                "NUM_RESULT" : null,
                "TIME" : null,
            }
        }
        new Vue({
            el: '#app',
            data: {
                id: '<%= @id %>',
                tests: [newTest(null, null)],
                compiling: false,
                buildResult: {
                    STDOUT: '',
                    STDERR: '',
                    STATUS: null
                },
                stdin: 'sardine',
                compileResult: 'none'
            },
            methods: {
                buildExec: async function(){
                    await this.build();
                    await this.exec();
                },
                buildRun: async function() {
                    if(await this.build()) this.exec()
                },
                build: function(){
                    if(this.compiling) return
                    this.compiling = true
                    this.compileResult = 'processing'
                    for(a in editor.session.getMarkers()) { editor.session.removeMarker(a) }
                    let body = new FormData()
                    body.set('id', this.id)
                    body.set('src', editor.getValue())
                    localStorage.setItem('src', editor.getValue())
                    return new Promise(resolve => {
                        fetch('/build', {
                            method: 'POST',
                            body
                        }).then(res => res.json())
                        .then(json => {
                            this.buildResult = json
                            this.compiling = false
                            let matches = json.STDERR.match(/Main.cpp:([0-9]+):[0-9]+/)
                            if(matches) {
                                let markers = {}
                                for(let i = 1; i < matches.length; i++) {
                                    markers[Number(matches[i])] = true
                                }
                                const n = editor.getSession().getValue().split("\n").length;
                                for(let i = 1; i < n; i++) {
                                    editor.session.addMarker(new AceRange(i, 1, i, 2), markers[i] ? "error" : "ok", "fullLine")
                                }
                            }
                            let result = json.STDERR == ""
                            
                            if(result) {
                                this.compileResult = 'success'
                            } else {
                                this.compileResult = 'failure'
                            }
                            resolve(result)
                        })
                    })
                },
                exec: async function(){
                    let tests = this.tests
                    let id = this.id

                    let backup = []
                    for(let i = 0; i < tests.length; i++) {
                        if(tests[i].STDIN) {
                            backup.push([tests[i].STDIN, tests[i].EXPECT])
                        }
                    }
                    localStorage.setItem('test', JSON.stringify(backup))
                    for(let i = 0; i < tests.length; i++) {
                        let test = tests[i]
                        if(test.STDIN) {
                            let body = new FormData()
                            body.set('id', id)
                            body.set('stdin', test.STDIN)
                            let start = new Date()
                            await (new Promise(resolve => {
                                fetch('/exec', {
                                    method: 'POST',
                                    body
                                }).then(res => res.json())
                                .then(json => {
                                    test.STDOUT = json.STDOUT
                                    test.STDERR = json.STDERR
                                    test.STATUS = json.STATUS
                                    test.TIME = (new Date()).getTime() - start.getTime()
                                    try {
                                        test.RESULT = test.STDOUT.trim() == test.EXPECT.trim()
                                        test.NUM_RESULT = test.RESULT || Math.abs(new Number(test.STDOUT.trim()) - new Number(test.EXPECT.trim()))
                                    } finally {
                                        resolve()
                                    }
                                })
                            }))
                        }
                    }
                },
                load: function(){
                    this.tests = 
                        JSON.parse(prompt('load test', localStorage.getItem("test") || '[["sardine","xxxxxxx"],["xxxx","xxxx"],["gone","xxxx"]]')).map(t => newTest(t[0], t[1]))
                },
                add: function(){
                    this.tests.push(newTest(null, null))
                }
            }
        })
    </script>
</body>
</html>